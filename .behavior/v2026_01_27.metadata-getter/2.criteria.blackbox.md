# usecase.1 = access typed metadata via getter

given('a HelpfulError with typed metadata generic')
  when('instantiated with metadata that matches the generic type')
    then('error.metadata returns the typed metadata object')
      sothat('developers can access metadata programmatically without parse of the message')
    then('error.metadata has the correct typescript type inferred from the generic')
      sothat('developers get autocomplete and type check on metadata access')

given('a HelpfulError instantiated without metadata')
  when('error.metadata is accessed')
    then('error.metadata returns undefined')
      sothat('optional metadata is handled gracefully')


# usecase.2 = constrain metadata input via generic

given('a subclass that extends HelpfulError<TMetadata> with a specific type')
  when('instantiated with metadata that matches TMetadata')
    then('the error is created successfully')
      sothat('valid metadata is accepted')
  when('instantiated with metadata that does NOT match TMetadata')
    then('typescript emits a type error')
      sothat('invalid metadata is caught at compile time')


# usecase.3 = backwards compatibility

given('prior code that uses HelpfulError without a generic type parameter')
  when('compiled and executed')
    then('the code compiles without errors')
      sothat('prior codebases are not broken')
    then('the error behaves identically to before')
      sothat('runtime behavior is preserved')

given('prior code that uses subclasses of HelpfulError (BadRequestError, UnexpectedCodePathError)')
  when('compiled and executed')
    then('the code compiles and runs without modification')
      sothat('all downstream users are unaffected')


# usecase.4 = stringify without redundant metadata

given('a HelpfulError with metadata')
  when('error.toString() or error.message is accessed')
    then('the message contains the serialized metadata exactly once')
      sothat('error messages remain readable and non-redundant')
  when('JSON.stringify(error) is called')
    then('the output does not contain duplicate metadata')
      sothat('json serialization remains clean')

given('error.metadata getter is accessed')
  when('the error is stringified afterward')
    then('the metadata is NOT serialized again')
      sothat('the getter does not cause side effects on stringification')


# usecase.5 = subclasses with typed metadata

given('a custom error class that extends HelpfulError<TMetadata>')
  when('instantiated')
    then('error.metadata returns the correctly typed metadata')
      sothat('subclasses inherit the typed getter behavior')
    then('the static .throw() method accepts only metadata that matches TMetadata')
      sothat('the convenience throw method is also type-safe')

given('BadRequestError or UnexpectedCodePathError with a generic type parameter')
  when('instantiated with typed metadata')
    then('error.metadata returns the typed metadata')
      sothat('built-in subclasses also support the new generic pattern')


# usecase.6 = type inference validation via ts-expect-error

given('a HelpfulError<{ foo: string }> subclass')
  when('instantiated with { foo: "bar" }')
    then('no typescript error occurs')
      sothat('valid metadata compiles')
  when('instantiated with { bar: "baz" } (wrong key)')
    then('typescript emits an error (provable via @ts-expect-error)')
      sothat('invalid metadata keys are caught at compile time')
  when('error.metadata.foo is accessed')
    then('typescript infers type string')
      sothat('metadata access is fully typed')
  when('error.metadata.bar (nonexistent key) is accessed')
    then('typescript emits an error (provable via @ts-expect-error)')
      sothat('invalid metadata access is caught at compile time')

# blueprint: metadata-getter

## overview

add a typed `metadata` getter to `HelpfulError` with generic constraint support, while:
- backwards compatibility is preserved
- redundant serialization on stringification is avoided
- type-safe metadata access and input constraints are enabled


---

## step.1 = extend HelpfulError class declaration with generic

**file:** `src/HelpfulError.ts`

**change:**
```ts
// before
export class HelpfulError extends Error {

// after
export class HelpfulError<
  TMetadata extends HelpfulErrorMetadata = HelpfulErrorMetadata,
> extends Error {
```

**rationale:**
- default `= HelpfulErrorMetadata` provides backwards compat
- `extends HelpfulErrorMetadata` ensures `cause?: Error` is always allowed


---

## step.2 = update constructor signature for TMetadata

**file:** `src/HelpfulError.ts`

**change:**
```ts
// before
constructor(message: string, metadata?: HelpfulErrorMetadata) {

// after
constructor(message: string, metadata?: TMetadata) {
```

**rationale:**
- constrains input metadata to match the declared generic type
- preserves optional metadata behavior


---

## step.3 = update private original property type

**file:** `src/HelpfulError.ts`

**change:**
```ts
// before
private readonly original!: {
  message: string;
  metadata?: HelpfulErrorMetadata;
  cause?: Error;
};

// after
private readonly original!: {
  message: string;
  metadata?: TMetadata;
  cause?: Error;
};
```

**rationale:**
- the stored metadata must match the generic type for correct getter type inference


---

## step.4 = add public metadata getter

**file:** `src/HelpfulError.ts`

**change:** add after the `original` property declaration
```ts
/**
 * .what = public accessor for the metadata passed to the error
 * .why = enables programmatic access to metadata without parse of the message
 * .note = getter is non-enumerable by default, so it won't pollute toJSON or Object.keys()
 */
public get metadata(): TMetadata | undefined {
  return this.original.metadata;
}
```

**rationale:**
- exposes `this.original.metadata` publicly
- getter is non-enumerable by default â€” no redundant serialization
- return type `TMetadata | undefined` provides full type inference


---

## step.5 = update static throw method signature

**file:** `src/HelpfulError.ts`

**change:**
```ts
// before
public static throw<T extends typeof HelpfulError>(
  this: T,
  message: string,
  metadata?: HelpfulErrorMetadata,
): never {

// after
public static throw<T extends typeof HelpfulError>(
  this: T,
  message: string,
  metadata?: InstanceType<T> extends HelpfulError<infer M> ? M : HelpfulErrorMetadata,
): never {
```

**rationale:**
- infers `TMetadata` from the subclass instance type
- constrains metadata to the declared generic when called on typed subclasses
- falls back to `HelpfulErrorMetadata` for untyped usage


---

## step.6 = update BadRequestError subclass

**file:** `src/BadRequestError.ts`

**change:**
```ts
// before
export class BadRequestError extends HelpfulError {
  constructor(message: string, metadata?: HelpfulErrorMetadata) {

// after
export class BadRequestError<
  TMetadata extends HelpfulErrorMetadata = HelpfulErrorMetadata,
> extends HelpfulError<TMetadata> {
  constructor(message: string, metadata?: TMetadata) {
```

**rationale:**
- passes generic through to HelpfulError
- enables `BadRequestError<{ foo: string }>` pattern
- default provides backwards compat


---

## step.7 = update UnexpectedCodePathError subclass

**file:** `src/UnexpectedCodePathError.ts`

**change:**
```ts
// before
export class UnexpectedCodePathError extends HelpfulError {
  constructor(message: string, metadata?: HelpfulErrorMetadata) {

// after
export class UnexpectedCodePathError<
  TMetadata extends HelpfulErrorMetadata = HelpfulErrorMetadata,
> extends HelpfulError<TMetadata> {
  constructor(message: string, metadata?: TMetadata) {
```

**rationale:**
- same pattern as BadRequestError
- maintains parity across built-in subclasses


---

## step.8 = add unit tests for metadata getter

**file:** `src/HelpfulError.test.ts`

**add describe block:**
```ts
describe('metadata', () => {
  it('should return the metadata passed to the error', () => {
    const error = new HelpfulError('test error', {
      userId: 123,
      action: 'test',
    });
    expect(error.metadata).toEqual({
      userId: 123,
      action: 'test',
    });
  });

  it('should return undefined when no metadata is passed', () => {
    const error = new HelpfulError('test error');
    expect(error.metadata).toBeUndefined();
  });

  it('should not include metadata in Object.keys enumeration', () => {
    const error = new HelpfulError('test error', { data: 'value' });
    const keys = Object.keys(error);
    expect(keys).not.toContain('metadata');
  });

  it('should not cause redundant serialization in JSON.stringify', () => {
    const error = new HelpfulError('test error', { data: 'value' });
    const json = JSON.stringify(error);
    const parsed = JSON.parse(json);
    expect(parsed.metadata).toBeUndefined();
    expect(json).toContain('data');
    expect(json).toContain('value');
  });
});
```

**rationale:**
- covers getter behavior
- proves no redundant serialization
- follows pattern.6 (cause property assertions) and pattern.8 (enumeration tests)


---

## step.9 = add unit tests for typed generic constraints

**file:** `src/HelpfulError.test.ts`

**add describe block:**
```ts
describe('typed metadata generic', () => {
  it('should constrain metadata input to match TMetadata', () => {
    class TypedError extends HelpfulError<{ foo: string; bar: number }> {}

    // valid metadata compiles and works
    const error = new TypedError('test', { foo: 'hello', bar: 42 });
    expect(error.metadata?.foo).toEqual('hello');
    expect(error.metadata?.bar).toEqual(42);

    // @ts-expect-error - wrong key should fail
    new TypedError('test', { wrong: 'key' });

    // @ts-expect-error - wrong type should fail
    new TypedError('test', { foo: 123, bar: 42 });
  });

  it('should provide typed access to metadata properties', () => {
    class TypedError extends HelpfulError<{ items: string[] }> {}
    const error = new TypedError('test', { items: ['a', 'b'] });

    // typescript should infer items as string[]
    const items = error.metadata?.items;
    expect(items).toEqual(['a', 'b']);

    // @ts-expect-error - nonexistent property should fail
    error.metadata?.nonexistent;
  });

  it('should work with nested typed metadata', () => {
    class TypedError extends HelpfulError<{
      options: { repl: string[]; atom: string[] };
    }> {}
    const error = new TypedError('test', {
      options: { repl: ['a', 'b'], atom: [] },
    });

    expect(error.metadata?.options.repl).toEqual(['a', 'b']);
    expect(error.metadata?.options.atom).toEqual([]);
  });

  it('should constrain metadata on static throw method', () => {
    class TypedError extends HelpfulError<{ reason: string }> {}

    // @ts-expect-error - wrong key should fail on throw
    TypedError.throw('error', { wrong: 'key' });
  });
});
```

**rationale:**
- proves input constraint via `@ts-expect-error`
- proves output access type via `@ts-expect-error`
- covers nested types per wish example
- follows pattern.NEW (ts-expect-error)


---

## step.10 = add unit tests for backwards compatibility

**file:** `src/HelpfulError.test.ts`

**add describe block:**
```ts
describe('backwards compatibility', () => {
  it('should work without generic type parameter', () => {
    const error = new HelpfulError('test', { any: 'metadata' });
    expect(error.metadata).toEqual({ any: 'metadata' });
    expect(error.message).toContain('any');
  });

  it('should allow cause in metadata without generic', () => {
    const cause = new Error('root');
    const error = new HelpfulError('test', { cause, extra: 'data' });
    expect(error.cause).toBe(cause);
    expect(error.metadata?.extra).toEqual('data');
  });
});
```

**rationale:**
- proves untyped usage still works
- proves cause handler unchanged


---

## step.11 = add unit tests for subclass typed metadata

**file:** `src/BadRequestError.test.ts`

**add describe block:**
```ts
describe('typed metadata generic', () => {
  it('should support typed metadata via generic', () => {
    class TypedBadRequest extends BadRequestError<{ field: string }> {}
    const error = new TypedBadRequest('invalid input', { field: 'email' });

    expect(error.metadata?.field).toEqual('email');
    expect(error).toBeInstanceOf(BadRequestError);
    expect(error).toBeInstanceOf(HelpfulError);
  });

  it('should constrain metadata input', () => {
    class TypedBadRequest extends BadRequestError<{ field: string }> {}

    // @ts-expect-error - wrong key
    new TypedBadRequest('error', { wrong: 'key' });
  });
});
```

**file:** `src/UnexpectedCodePathError.test.ts`

**add similar describe block** with same pattern


---

## step.12 = verify all prior tests pass

**action:** run full test suite
```sh
npm run test
```

**rationale:**
- ensures backwards compat
- catches any regressions


---

## step.13 = verify type checks pass

**action:** run type check
```sh
npm run test:types
```

**rationale:**
- ensures all `@ts-expect-error` annotations are valid
- catches any type regressions


---

## summary of files changed

| file | action | changes |
|------|--------|---------|
| `src/HelpfulError.ts` | **MODIFY** | add generic, update constructor, add getter, update throw |
| `src/BadRequestError.ts` | **MODIFY** | add generic, update constructor |
| `src/UnexpectedCodePathError.ts` | **MODIFY** | add generic, update constructor |
| `src/HelpfulError.test.ts` | **MODIFY** | add metadata, typed generic, backwards compat tests |
| `src/BadRequestError.test.ts` | **MODIFY** | add typed metadata tests |
| `src/UnexpectedCodePathError.test.ts` | **MODIFY** | add typed metadata tests |


---

## test coverage matrix

| usecase | test type | test location |
|---------|-----------|---------------|
| access typed metadata via getter | unit | `HelpfulError.test.ts` > `metadata` |
| constrain metadata input via generic | unit | `HelpfulError.test.ts` > `typed metadata generic` |
| backwards compatibility | unit | `HelpfulError.test.ts` > `backwards compatibility` |
| stringify without redundant metadata | unit | `HelpfulError.test.ts` > `metadata` |
| subclasses with typed metadata | unit | `BadRequestError.test.ts`, `UnexpectedCodePathError.test.ts` |
| type inference validation via ts-expect-error | unit | `HelpfulError.test.ts` > `typed metadata generic` |


---

## risk assessment

| risk | mitigation |
|------|------------|
| generic inference breaks static methods | use `InstanceType<T> extends HelpfulError<infer M>` pattern |
| redundant serialization | getter is non-enumerable by default; add explicit test |
| backwards compat breakage | default generic `= HelpfulErrorMetadata`; run full suite |
| subclass type complexity | follow same pattern for all subclasses |

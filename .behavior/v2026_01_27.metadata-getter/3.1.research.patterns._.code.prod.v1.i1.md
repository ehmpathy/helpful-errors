# research: production code patterns

## pattern.1 = HelpfulErrorMetadata type definition

**[EXTEND]**

the base type for metadata accepted by HelpfulError.

```ts
// [1] src/HelpfulError.ts:8-16
export type HelpfulErrorMetadata = Record<string, any> & {
  /**
   * .what = declares the error that triggered this error
   * .why = enables stacktrace of both errors to be visible
   *   - exposes the full stacktrace trail of each error
   *   - includes links to each file:line where each error was thrown
   */
  cause?: Error;
};
```

**relation to wish:**
- the wish requires `HelpfulError<TMetadata>` generic to constrain metadata
- this type will need to be extended or parameterized to support a generic constraint
- the `cause?: Error` must be preserved for backwards compat


---

## pattern.2 = private `original` property for internal storage

**[REUSE]**

the constructor stores the original message, metadata, and cause in a non-enumerable property.

```ts
// [2] src/HelpfulError.ts:46-56
    // store the original message, metadata, and cause for later access (non-enumerable)
    Object.defineProperty(this, 'original', {
      value: {
        message,
        metadata,
        cause: metadata?.cause,
      },
      enumerable: false, // non enumerable, so it wont pollute toJSON, Object.keys(), nor for...in loops; its only intended for internal use
      writable: false,
      configurable: false,
    });
```

```ts
// [3] src/HelpfulError.ts:59-66
  /**
   * the original message and metadata, before been formatted into the error message
   */
  private readonly original!: {
    message: string;
    metadata?: HelpfulErrorMetadata;
    cause?: Error;
  };
```

**relation to wish:**
- the metadata is already stored in `this.original.metadata`
- a getter can expose `this.original.metadata` publicly
- the non-enumerable pattern prevents redundant serialization — exactly what the wish requires


---

## pattern.3 = constructor signature and metadata transform

**[EXTEND]**

the constructor accepts `message: string` and optional `metadata?: HelpfulErrorMetadata`.

```ts
// [4] src/HelpfulError.ts:30
  constructor(message: string, metadata?: HelpfulErrorMetadata) {
```

```ts
// [5] src/HelpfulError.ts:31-43
    const metadataWithoutCause = metadata
      ? omit(metadata, ['cause'])
      : metadata;
    const fullMessage = [
      message,
      metadataWithoutCause && Object.keys(metadataWithoutCause).length
        ? getEnvOptions().expand
          ? JSON.stringify(metadataWithoutCause, null, 2)
          : JSON.stringify(metadataWithoutCause)
        : null,
    ]
      .filter(isPresent)
      .join('\n\n');
    super(fullMessage, metadata?.cause ? { cause: metadata.cause } : undefined);
```

**relation to wish:**
- the constructor signature must support `TMetadata` generic constraint on the `metadata` parameter
- the metadata transform logic will be unchanged (no redundant serialization impact)


---

## pattern.4 = static `throw` method with polymorphic this

**[EXTEND]**

the static throw method uses `this: T` pattern for correct subclass instantiation.

```ts
// [6] src/HelpfulError.ts:76-83
  public static throw<T extends typeof HelpfulError>(
    this: T, // https://stackoverflow.com/a/51749145/3068233
    message: string,
    metadata?: HelpfulErrorMetadata,
  ): never {
    // eslint-disable-next-line @typescript-eslint/no-throw-literal
    throw new this(message, metadata) as InstanceType<T>;
  }
```

**relation to wish:**
- the metadata parameter must be constrained by `TMetadata` when subclasses declare a generic
- the `this: T` pattern must be preserved for polymorphic behavior


---

## pattern.5 = static `wrap` method with overloads

**[REUSE]**

the static wrap method has multiple overloads for sync and async functions.

```ts
// [7] src/HelpfulError.ts:96-133
  public static wrap<
    T extends typeof HelpfulError,
    TLogic extends (...args: any[]) => Promise<any>,
  >(
    this: T,
    logic: TLogic,
    options: {
      message: string;
      metadata: Record<string, any>;
    },
  ): (...args: Parameters<TLogic>) => Promise<Awaited<ReturnType<TLogic>>>;
  // ... additional overloads ...
  public static wrap<
    T extends typeof HelpfulError,
    TLogic extends (...args: any[]) => any,
  >(
    this: T,
    logic: TLogic,
    options: {
      message: string;
      metadata: Record<string, any>;
    },
  ): TLogic {
    return withHelpfulError(logic, {
      variant: this,
      ...options,
    });
  }
```

**relation to wish:**
- wrap uses `Record<string, any>` for metadata, not `HelpfulErrorMetadata`
- this pattern can remain unchanged — the generic constraint is for instantiation, not wrap


---

## pattern.6 = `redact` method accesses `this.original`

**[REUSE]**

the redact method reads from `this.original.metadata` internally.

```ts
// [8] src/HelpfulError.ts:147-173
  public redact(parts: Array<'metadata' | 'cause'>): this {
    // determine what to include based on what gets redacted
    const shouldIncludeMetadata = !parts.includes('metadata');
    const shouldIncludeCause = !parts.includes('cause');

    // build the metadata object for the new instance
    const newMetadata: HelpfulErrorMetadata | undefined = (() => {
      // ... logic that uses this.original.metadata and this.original.cause ...
    })();

    // create a new instance with the original message and filtered metadata
    return new (this.constructor as any)(this.original.message, newMetadata);
  }
```

**relation to wish:**
- redact already uses `this.original.metadata` internally
- the public getter will expose the same data path
- return type `this` will preserve typed metadata on the returned clone


---

## pattern.7 = `toJSON` method excludes `original`

**[REUSE]**

the toJSON method explicitly filters out the `original` property.

```ts
// [9] src/HelpfulError.ts:182-193
  toJSON<T extends typeof HelpfulError>(
    this: T, // https://stackoverflow.com/a/51749145/3068233
  ): Record<string, any> {
    const obj: Record<string, any> = {};
    Object.getOwnPropertyNames(this)
      .filter((key) => key !== 'original')
      .sort()
      .forEach((key) => {
        obj[key] = (this as any)[key as any];
      }, this);
    return obj;
  }
```

**relation to wish:**
- the toJSON method will need to also exclude the `metadata` getter if it becomes enumerable
- alternatively, if the getter is non-enumerable, no change is needed
- a getter defined via `get metadata()` is non-enumerable by default — so no change required


---

## pattern.8 = subclass constructor pattern

**[EXTEND]**

subclasses call `super()` with a prefixed message.

```ts
// [10] src/BadRequestError.ts:13-16
export class BadRequestError extends HelpfulError {
  constructor(message: string, metadata?: HelpfulErrorMetadata) {
    super(['BadRequestError: ', message].join(''), metadata);
  }
}
```

```ts
// [11] src/UnexpectedCodePathError.ts:6-9
export class UnexpectedCodePathError extends HelpfulError {
  constructor(message: string, metadata?: HelpfulErrorMetadata) {
    super(['UnexpectedCodePathError: ', message].join(''), metadata);
  }
}
```

**relation to wish:**
- subclasses must be updated to support `TMetadata` generic
- the pattern `extends HelpfulError<TMetadata>` must be supported
- backwards compat: `extends HelpfulError` (no generic) must still work


---

## pattern.9 = class declaration extends Error

**[EXTEND]**

the base class extends native Error.

```ts
// [12] src/HelpfulError.ts:21
export class HelpfulError extends Error {
```

**relation to wish:**
- must become `export class HelpfulError<TMetadata extends HelpfulErrorMetadata = HelpfulErrorMetadata> extends Error`
- the default `= HelpfulErrorMetadata` provides backwards compat


---

## pattern.10 = withHelpfulError function

**[REUSE]**

standalone wrapper function that creates error instances.

```ts
// [13] src/withHelpfulError.ts:25-56
export function withHelpfulError<TLogic extends (...args: any[]) => any>(
  logic: TLogic,
  options: {
    variant?: typeof HelpfulError;
    message: string;
    metadata: Record<string, any>;
  },
): TLogic {
  const Constructor = options.variant ?? HelpfulError;
  const wrapped = (...args: Parameters<TLogic>): ReturnType<TLogic> => {
    try {
      const result = logic(...args);
      if (result instanceof Promise) {
        return result.catch((error) => {
          if (!(error instanceof Error)) throw error;
          throw new Constructor(options.message, {
            ...options.metadata,
            cause: error,
          });
        }) as ReturnType<TLogic>;
      }
      return result;
    } catch (error) {
      if (!(error instanceof Error)) throw error;
      throw new Constructor(options.message, {
        ...options.metadata,
        cause: error,
      });
    }
  };
  return wrapped as TLogic;
}
```

**relation to wish:**
- this function uses `typeof HelpfulError` for the variant
- the generic change to HelpfulError should be transparent here
- no changes required


---

## pattern.11 = NoErrorThrownError subclass

**[REUSE]**

a simple subclass with no metadata.

```ts
// [14] src/getError.ts:6-10
export class NoErrorThrownError extends HelpfulError {
  constructor() {
    super('no error was thrown');
  }
}
```

**relation to wish:**
- this subclass uses no metadata
- it will continue to work unchanged due to backwards compat defaults


---

## summary

| pattern | action | rationale |
|---------|--------|-----------|
| HelpfulErrorMetadata type | **EXTEND** | add generic param, preserve cause |
| private `original` property | **REUSE** | already stores metadata, non-enumerable |
| constructor signature | **EXTEND** | add `TMetadata` constraint on metadata param |
| static `throw` method | **EXTEND** | add `TMetadata` constraint on metadata param |
| static `wrap` method | **REUSE** | uses `Record<string, any>`, unchanged |
| `redact` method | **REUSE** | already uses `this.original.metadata` |
| `toJSON` method | **REUSE** | getter is non-enumerable by default |
| subclass constructor pattern | **EXTEND** | support `extends HelpfulError<T>` |
| class declaration | **EXTEND** | add `<TMetadata = HelpfulErrorMetadata>` |
| withHelpfulError function | **REUSE** | transparent to generic change |
| NoErrorThrownError | **REUSE** | no metadata, unchanged |

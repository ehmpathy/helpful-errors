# research: test code patterns

## pattern.1 = describe/it structure with nested describe blocks

**[REUSE]**

tests are organized with top-level `describe` for the class, nested `describe` for methods/features.

```ts
// [1] src/HelpfulError.test.ts:9
describe('HelpfulError', () => {
```

```ts
// [2] src/HelpfulError.test.ts:59
  describe('original', () => {
```

```ts
// [3] src/HelpfulError.test.ts:86
  describe('wrap', () => {
    describe('sync logic', () => {
```

```ts
// [4] src/HelpfulError.test.ts:168
  describe('redact', () => {
    describe('generally', () => {
```

**relation to wish:**
- new tests for `metadata` getter will follow the same nested describe pattern
- add `describe('metadata', () => { ... })` block


---

## pattern.2 = getError utility for error capture

**[REUSE]**

the `getError` utility captures thrown errors for assertions without try/catch in tests.

```ts
// [5] src/HelpfulError.test.ts:17-31
    const error = getError(() => {
      // this case should not throw
      const customerOne: { phone: string | null } = {
        phone: 'yes',
      };
      const phoneOne =
        customerOne.phone ?? HelpfulError.throw('phone one not found!');

      // but this case should throw
      const customerTwo: { phone: string | null } = {
        phone: null,
      };
      const phoneTwo =
        customerTwo.phone ?? HelpfulError.throw('phone two not found!');
    });
```

```ts
// [6] src/getError.test.ts:5-12
  it('can get error from synchronous logic', () => {
    const doSomething: () => void = () => {
      throw new HelpfulError('found me');
    };
    const error = getError(() => doSomething());
    expect(error).toBeInstanceOf(HelpfulError);
    expect(error.message).toContain('found me');
  });
```

**relation to wish:**
- no changes needed â€” getError works for any error tests


---

## pattern.3 = snapshot assertions for error shape

**[EXTEND]**

snapshots capture the full error representation for regression tests.

```ts
// [7] src/HelpfulError.test.ts:10-15
  it('should produce a helpful, observable error message', () => {
    const error = new HelpfulError('could not get joke about paper', {
      why: 'it was tearable', // ðŸ˜‚
    });
    expect(error).toMatchSnapshot();
  });
```

```ts
// [8] src/__snapshots__/HelpfulError.test.ts.snap:27-31
exports[`HelpfulError should produce a helpful, observable error message 1`] = `
[Error: could not get joke about paper

{"why":"it was tearable"}]
`;
```

**relation to wish:**
- new tests for metadata getter may add snapshots
- snapshots must NOT include a separate `metadata` property (no redundant serialization)


---

## pattern.4 = instanceof assertions

**[REUSE]**

verify error class hierarchy with `toBeInstanceOf`.

```ts
// [9] src/HelpfulError.test.ts:32
    expect(error).toBeInstanceOf(HelpfulError);
```

```ts
// [10] src/BadRequestError.test.ts:27
    expect(error).toBeInstanceOf(BadRequestError);
```

```ts
// [11] src/HelpfulError.test.ts:163
      expect(error).toBeInstanceOf(CustomError);
```

**relation to wish:**
- reuse as-is for typed subclass tests


---

## pattern.5 = message content assertions

**[REUSE]**

verify message contains expected strings.

```ts
// [12] src/HelpfulError.test.ts:33
    expect(error.message).toEqual('phone two not found!');
```

```ts
// [13] src/HelpfulError.test.ts:56-57
    expect(json).toContain('joke about pizza');
    expect(json).toContain('it was too cheesy');
```

**relation to wish:**
- reuse for assertions that message still contains serialized metadata


---

## pattern.6 = cause property assertions

**[REUSE]**

verify the `.cause` property is set correctly.

```ts
// [14] src/HelpfulError.test.ts:41-42
    expect(errorHelpful.cause).toBeDefined();
    expect(errorHelpful.cause).toMatchSnapshot();
```

```ts
// [15] src/HelpfulError.test.ts:101
        expect((error.cause as Error).message).toBe('original error');
```

**relation to wish:**
- similar pattern will be used for `.metadata` property assertions
- `expect(error.metadata).toBeDefined()` and `expect(error.metadata.foo).toEqual(...)`


---

## pattern.7 = JSON serialization tests

**[EXTEND]**

verify JSON.stringify behavior.

```ts
// [16] src/HelpfulError.test.ts:51-58
  it('should serialize to json expressively', () => {
    const error = new HelpfulError('could not get joke about pizza', {
      why: 'it was too cheesy', // ðŸ˜‚
    });
    const json = JSON.stringify(error);
    expect(json).toContain('joke about pizza');
    expect(json).toContain('it was too cheesy');
  });
```

```ts
// [17] src/HelpfulError.test.ts:60-66
    it('should not include the original property in JSON serialization', () => {
      const error = new HelpfulError('test error', {
        data: 'metadata',
      });
      const json = JSON.stringify(error);
      expect(json).not.toContain('original');
    });
```

**relation to wish:**
- must add test that metadata getter does NOT cause redundant serialization
- `expect(json).not.toContain('"metadata":')` (as a top-level key)


---

## pattern.8 = Object.keys enumeration tests

**[EXTEND]**

verify non-enumerable properties are not exposed.

```ts
// [18] src/HelpfulError.test.ts:67-73
    it('should not enumerate the original property', () => {
      const error = new HelpfulError('test error', {
        data: 'metadata',
      });
      const keys = Object.keys(error);
      expect(keys).not.toContain('original');
    });
```

**relation to wish:**
- getter properties are non-enumerable by default
- may add test to confirm: `expect(Object.keys(error)).not.toContain('metadata')`


---

## pattern.9 = jest.mock for env options

**[REUSE]**

mock the env module to control expand behavior.

```ts
// [19] src/HelpfulError.test.ts:5-7
jest.mock('./utils/env');
const getEnvOptionsMock = getEnvOptions as jest.Mock;
getEnvOptionsMock.mockReturnValue({ expand: false });
```

```ts
// [20] src/HelpfulError.test.ts:45
    getEnvOptionsMock.mockReturnValueOnce({ expand: true });
```

**relation to wish:**
- no changes needed â€” metadata getter is independent of env options


---

## pattern.10 = inline subclass definition in tests

**[EXTEND]**

define custom error subclasses inline for test scenarios.

```ts
// [21] src/HelpfulError.test.ts:148-152
      class CustomError extends HelpfulError {
        constructor(message: string, metadata?: HelpfulErrorMetadata) {
          super(['CustomError: ', message].join(''), metadata);
        }
      }
```

**relation to wish:**
- must add typed subclass test: `class TypedError extends HelpfulError<{ foo: string }>`
- this pattern supports the new generic constraint tests


---

## pattern.11 = ternary throw pattern tests

**[EXTEND]**

test the static `.throw()` method in `??` expressions.

```ts
// [22] src/HelpfulError.test.ts:16-34
  it('should be throwable in a ternary conveniently and precisely', () => {
    const error = getError(() => {
      // this case should not throw
      const customerOne: { phone: string | null } = {
        phone: 'yes',
      };
      const phoneOne =
        customerOne.phone ?? HelpfulError.throw('phone one not found!');

      // but this case should throw
      const customerTwo: { phone: string | null } = {
        phone: null,
      };
      const phoneTwo =
        customerTwo.phone ?? HelpfulError.throw('phone two not found!');
    });
    expect(error).toBeInstanceOf(HelpfulError);
    expect(error.message).toEqual('phone two not found!');
  });
```

**relation to wish:**
- must add typed `.throw()` tests with generic constraint
- verify metadata type is constrained on the throw method


---

## pattern.12 = subclass observable message tests

**[REUSE]**

verify subclass prefix appears in message.

```ts
// [23] src/BadRequestError.test.ts:5-10
  it('should produce a helpful, observable error message', () => {
    const error = new BadRequestError('no tires on the vehicle', {
      tires: [],
    });
    expect(error).toMatchSnapshot();
  });
```

```ts
// [24] src/__snapshots__/BadRequestError.test.ts.snap:3-9
exports[`BadRequestError should produce a helpful, observable error message 1`] = `
[Error: BadRequestError: no tires on the vehicle

{
  "tires": []
}]
`;
```

**relation to wish:**
- must add tests for `BadRequestError<TMetadata>` and `UnexpectedCodePathError<TMetadata>`


---

## pattern.13 = internal property access via public method

**[REUSE]**

test internal behavior indirectly through public methods.

```ts
// [25] src/HelpfulError.test.ts:74-84
    it('should still allow internal access to the original property', () => {
      const originalError = new Error('cause');
      const error = new HelpfulError('test error', {
        data: 'metadata',
        cause: originalError,
      });
      // The redact method uses the original property internally
      const redacted = error.redact(['metadata']);
      expect(redacted.message).toBe('test error');
      expect(redacted.cause).toBe(originalError);
    });
```

**relation to wish:**
- the new `metadata` getter provides direct public access
- tests will directly access `error.metadata` rather than indirectly via redact


---

## pattern.NEW = ts-expect-error for type constraint validation

**[NEW]**

the wish requires tests that prove typescript type constraints via `@ts-expect-error`.

this pattern is NOT in the current codebase. it must be added.

```ts
// example pattern to add:
it('should emit a type error when metadata does not match TMetadata', () => {
  class TypedError extends HelpfulError<{ foo: string }> {}

  // valid metadata compiles
  new TypedError('message', { foo: 'bar' });

  // invalid metadata causes type error
  // @ts-expect-error - bar is not a valid key
  new TypedError('message', { bar: 'baz' });
});
```

**relation to wish:**
- this is explicitly required by the wish
- proves both input constraint and output access type


---

## summary

| pattern | action | rationale |
|---------|--------|-----------|
| describe/it structure | **REUSE** | add nested describe for metadata |
| getError utility | **REUSE** | unchanged |
| snapshot assertions | **EXTEND** | verify no redundant serialization |
| instanceof assertions | **REUSE** | unchanged |
| message content assertions | **REUSE** | unchanged |
| cause property assertions | **REUSE** | similar pattern for metadata |
| JSON serialization tests | **EXTEND** | verify no metadata key in json |
| Object.keys enumeration tests | **EXTEND** | verify metadata getter non-enumerable |
| jest.mock for env | **REUSE** | unchanged |
| inline subclass definition | **EXTEND** | add typed subclass pattern |
| ternary throw pattern | **EXTEND** | add typed throw tests |
| subclass observable message | **REUSE** | unchanged |
| internal property access | **REUSE** | direct access now via getter |
| ts-expect-error pattern | **NEW** | required by wish for type proofs |

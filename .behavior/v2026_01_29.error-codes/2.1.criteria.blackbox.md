# blackbox criteria: error codes

> what experience must be delivered to fulfill the wish

---

# usecase.1 = extract code from error

given('any error instance')
  when('the error has a code defined')
    then('error.code returns the code object')
      sothat('handlers can read error.code.http for status')
      sothat('handlers can read error.code.slug for machine-readable type')
    then('error.code.http is a number or undefined')
    then('error.code.slug is a string or undefined')

  when('the error has no code defined')
    then('error.code returns undefined')
      sothat('handlers can safely use error.code?.http ?? 500')

---

# usecase.2 = default codes on built-in errors

given('a HelpfulError instance')
  when('no code is supplied')
    then('error.code is undefined')
      sothat('no assumptions are made about http status')

given('a BadRequestError instance')
  when('no code is supplied')
    then('error.code.http is 400')
      sothat('handlers know this is a client error')
    then('error.code.slug is undefined')
      sothat('throwers can supply their own slug')

given('an UnexpectedCodePathError instance')
  when('no code is supplied')
    then('error.code.http is 500')
      sothat('handlers know this is a server error')
    then('error.code.slug is undefined')
      sothat('throwers can supply their own slug')

---

# usecase.3 = supply code at throw time

given('a throw with code in metadata')
  when('code has both http and slug')
    then('error.code reflects both values')
      sothat('throwers can fully specify the code')

  when('code has only slug')
    then('error.code.slug reflects the value')
    then('error.code.http inherits from class default')
      sothat('throwers can specialize slug without repeat of http')

  when('code has only http')
    then('error.code.http reflects the value')
    then('error.code.slug inherits from class default')
      sothat('throwers can override http without loss of slug')

  when('code is null')
    then('error.code is undefined')
      sothat('throwers can explicitly opt out of any code')

given('a throw with other metadata alongside code')
  when('metadata contains code and other fields')
    then('error.code reflects the code')
    then('error.metadata contains all fields')
      sothat('code does not interfere with other metadata')

---

# usecase.4 = define error class with baked-in code

given('a custom error class that extends BadRequestError')
  when('the class declares static code = { http: 402, slug: "DECLINED:PAYMENT" }')
    then('instances of that class have error.code.http = 402')
    then('instances of that class have error.code.slug = "DECLINED:PAYMENT"')
      sothat('class authors can bake in standard codes')

given('a custom error class that extends HelpfulError')
  when('the class declares static code = { slug: "CUSTOM" }')
    then('instances have error.code.slug = "CUSTOM"')
    then('instances have error.code.http = undefined')
      sothat('class authors can define slug-only codes')

---

# usecase.5 = inherit code through class hierarchy

given('class A extends class B extends HelpfulError')
  when('B declares static code and A does not')
    then('instances of A have error.code from B')
      sothat('subclasses inherit parent codes automatically')

  when('both A and B declare static code')
    then('instances of A have error.code from A')
      sothat('subclasses can override parent codes')

  when('neither A nor B declare static code')
    then('instances of A have error.code = undefined')
      sothat('no code is assumed without declaration')

---

# usecase.6 = merge instance code with class code

given('a class with static code = { http: 400, slug: "CLASS_SLUG" }')
  when('instance is thrown with { code: { slug: "INSTANCE_SLUG" } }')
    then('error.code.slug = "INSTANCE_SLUG"')
    then('error.code.http = 400')
      sothat('instance slug overrides class slug')
      sothat('class http is preserved when instance omits it')

  when('instance is thrown with { code: { http: 422 } }')
    then('error.code.http = 422')
    then('error.code.slug = "CLASS_SLUG"')
      sothat('instance http overrides class http')
      sothat('class slug is preserved when instance omits it')

  when('instance is thrown with { code: { http: 422, slug: "INSTANCE_SLUG" } }')
    then('error.code.http = 422')
    then('error.code.slug = "INSTANCE_SLUG"')
      sothat('instance fully overrides class code')

---

# usecase.7 = partial codes are valid

given('an error with only http code')
  when('error.code = { http: 418 }')
    then('error.code.http = 418')
    then('error.code.slug = undefined')
      sothat('http-only codes are supported')

given('an error with only slug')
  when('error.code = { slug: "TEAPOT" }')
    then('error.code.slug = "TEAPOT"')
    then('error.code.http = undefined')
      sothat('slug-only codes are supported')

---

# usecase.8 = serialization omits code without slug

given('an error with default http code but no slug')
  when('error is serialized (toJSON, logs)')
    then('code is omitted from output')
      sothat('logs are not spammed with { code: { http: 400 } }')
      sothat('only meaningful codes appear in observability')

given('an error with a slug')
  when('error is serialized (toJSON, logs)')
    then('code appears in output with both http and slug')
      sothat('observers see the full code when it matters')

given('a BadRequestError with no code supplied')
  when('error.code getter is called')
    then('returns { http: 400 }')
      sothat('programmatic access still works')
  when('error is serialized')
    then('code is omitted')
      sothat('default codes don't clutter logs')

given('a BadRequestError with slug supplied')
  when('error.code getter is called')
    then('returns { http: 400, slug: "X" }')
  when('error is serialized')
    then('code appears as { http: 400, slug: "X" }')
      sothat('explicit codes are visible in logs')

given('a custom error class with static code = { http: 402, slug: "DECLINED:PAYMENT" }')
  when('instance is serialized')
    then('code appears in output')
      sothat('class-level slugs are always visible')

---

# usecase.9 = backwards compatibility

given('code that worked before this feature')
  when('errors are thrown without code in metadata')
    then('error behavior is unchanged')
    then('error.message is unchanged')
    then('error.metadata is unchanged')
      sothat('prior code continues to work')

given('code that catches errors')
  when('the error has no code property')
    then('error.code returns undefined, not an error')
      sothat('handlers don't break on old errors')

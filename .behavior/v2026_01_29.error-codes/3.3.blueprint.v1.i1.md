# blueprint: error codes

> how we implement the wish

---

## references

- wish: .behavior/v2026_01_29.error-codes/0.wish.md
- vision: .behavior/v2026_01_29.error-codes/1.vision.md
- blackbox criteria: .behavior/v2026_01_29.error-codes/2.1.criteria.blackbox.md
- blueprint criteria: .behavior/v2026_01_29.error-codes/2.3.criteria.blueprint.md

---

## treestruct: filediffs

```
src/
  [~] index.ts                           # export HelpfulErrorCode type
  [~] HelpfulError.ts                    # add code type, static, getter, toJSON update
  [~] HelpfulError.test.ts               # add code tests
  [~] BadRequestError.ts                 # add static code = { http: 400 }
  [~] BadRequestError.test.ts            # add code tests
  [~] UnexpectedCodePathError.ts         # add static code = { http: 500 }
  [~] UnexpectedCodePathError.test.ts    # add code tests
```

**legend**: `[+]` create, `[~]` update, `[-]` delete

---

## treestruct: codepaths

### HelpfulError.ts

```
HelpfulErrorCode type
  [+] export type HelpfulErrorCode = { http?: number; slug?: string }

HelpfulError class
  [+] static code: HelpfulErrorCode | undefined = undefined

  constructor()
    [○] retain message format
    [○] retain cause extraction
    [~] update metadataWithoutCause to also omit 'code'
    [~] update original storage to include code separately

  original (private)
    [~] add code?: HelpfulErrorCode | null field

  [+] get code(): HelpfulErrorCode | undefined
      // merge class static code with instance code
      // instance fields override class fields
      // return undefined if no code anywhere
      // code: null in metadata clears code entirely

  get metadata()
    [~] return metadata without code field (omit 'code')

  toJSON()
    [~] conditionally include code only when slug present
```

### BadRequestError.ts

```
BadRequestError class
  [+] static code = { http: 400 } as const
  [○] retain constructor
```

### UnexpectedCodePathError.ts

```
UnexpectedCodePathError class
  [+] static code = { http: 500 } as const
  [○] retain constructor
```

### index.ts

```
exports
  [+] export type { HelpfulErrorCode } from './HelpfulError'
  [○] retain other exports
```

**legend**: `[+]` create, `[~]` update, `[○]` retain, `[-]` delete, `[←]` reuse, `[→]` eject

---

## contracts

### HelpfulErrorCode type

```ts
/**
 * .what = error code with optional http status and machine-readable slug
 * .why = enables declarative error classification
 */
export type HelpfulErrorCode = {
  http?: number;
  slug?: string;
};
```

### HelpfulError.code getter

```ts
/**
 * .what = accessor for merged error code (class + instance)
 * .why = enables programmatic access to error classification
 */
public get code(): HelpfulErrorCode | undefined {
  // get class static code via prototype chain
  const classCode = (this.constructor as typeof HelpfulError).code;

  // get instance code from original
  const instanceCode = this.original.code;

  // handle explicit null (opt-out)
  if (instanceCode === null) return undefined;

  // merge: instance fields override class fields
  if (!classCode && !instanceCode) return undefined;

  return {
    ...classCode,
    ...instanceCode,
  };
}
```

### toJSON code inclusion

```ts
/**
 * .what = serialize error to json, include code only when slug present
 * .why = prevents log spam with default http codes
 */
toJSON(): Record<string, any> {
  const obj: Record<string, any> = {};

  // prior property enumeration
  Object.getOwnPropertyNames(this)
    .filter((key) => key !== 'original')
    .sort()
    .forEach((key) => {
      obj[key] = (this as any)[key];
    });

  // conditionally add code if slug present
  const code = this.code;
  if (code?.slug) {
    obj.code = code;
  }

  return obj;
}
```

---

## composition

### code resolution flow

```
throw new BadRequestError('x', { code: { slug: 'Y' } })
  │
  ├─ constructor stores code in original.code
  │
  └─ .code getter called
       │
       ├─ read BadRequestError.code (static) → { http: 400 }
       │
       ├─ read original.code → { slug: 'Y' }
       │
       └─ merge → { http: 400, slug: 'Y' }
```

### serialization flow

```
JSON.stringify(error)
  │
  └─ toJSON() called
       │
       ├─ enumerate own properties (message, stack, etc)
       │
       ├─ check this.code?.slug
       │    │
       │    ├─ if slug present → include code in output
       │    │
       │    └─ if no slug → omit code
       │
       └─ return obj
```

### metadata isolation

```
error.metadata
  │
  └─ returns original.metadata without 'code' field
       │
       └─ ensures code doesn't appear twice in serialization
            (once in error.code, once in metadata)
```

---

## test coverage

### unit tests: HelpfulError.test.ts

```ts
describe('code', () => {
  describe('getter', () => {
    it('returns undefined for base HelpfulError')
    it('returns class code when no instance code')
    it('returns instance code when no class code')
    it('merges instance code over class code')
    it('returns undefined when code: null in metadata')
  })

  describe('static code', () => {
    it('HelpfulError.code is undefined')
  })

  describe('serialization', () => {
    it('omits code from toJSON when no slug')
    it('includes code in toJSON when slug present')
    it('includes full merged code in toJSON')
  })

  describe('metadata isolation', () => {
    it('error.metadata does not include code field')
    it('code in metadata does not appear in message')
  })

  describe('inheritance', () => {
    it('custom subclass inherits parent code')
    it('custom subclass can override parent code')
    it('multi-level inheritance works')
  })
})
```

### unit tests: BadRequestError.test.ts

```ts
describe('code', () => {
  it('has static code = { http: 400 }')
  it('instance.code.http is 400')
  it('instance.code.slug is undefined by default')
  it('instance can override with slug')
  it('instance can override http')
  it('toJSON omits code (no slug by default)')
  it('toJSON includes code when slug supplied')
})
```

### unit tests: UnexpectedCodePathError.test.ts

```ts
describe('code', () => {
  it('has static code = { http: 500 }')
  it('instance.code.http is 500')
  it('instance.code.slug is undefined by default')
  it('instance can override with slug')
  it('toJSON omits code (no slug by default)')
})
```

### integration tests: HelpfulError.test.ts

```ts
describe('code integration', () => {
  it('full throw-catch-serialize cycle preserves code')
  it('error.code accessible in catch block')
  it('JSON.stringify produces expected output with slug')
  it('JSON.stringify produces expected output without slug')
})
```

### backwards compatibility tests

```ts
describe('backwards compatibility', () => {
  it('prior error instantiation patterns still work')
  it('error.message unchanged')
  it('error.metadata unchanged for non-code metadata')
  it('errors without code work as before')
})
```

---

## execution phases

### phase 1: type and static code

1. add `HelpfulErrorCode` type to HelpfulError.ts
2. add `static code = undefined` to HelpfulError
3. add `static code = { http: 400 }` to BadRequestError
4. add `static code = { http: 500 }` to UnexpectedCodePathError
5. export `HelpfulErrorCode` from index.ts

### phase 2: code getter

1. update `original` type to include `code?: HelpfulErrorCode | null`
2. update constructor to store `code` from metadata
3. implement `code` getter with merge logic
4. update `metadata` getter to omit `code`

### phase 3: serialization

1. update `toJSON` to conditionally include code
2. update constructor to omit `code` from message serialization

### phase 4: tests

1. add unit tests for code getter
2. add unit tests for static codes on subclasses
3. add unit tests for serialization behavior
4. add integration tests for full cycle
5. add backwards compatibility tests

### phase 5: validation

1. run `npm run test:types`
2. run `npm run test:unit`
3. run `npm run test:lint`
4. verify all criteria satisfied

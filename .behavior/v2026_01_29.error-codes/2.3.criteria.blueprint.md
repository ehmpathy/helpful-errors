# blueprint criteria: error codes

> what mechanisms must exist to deliver the blackbox experience

---

## blackbox criteria satisfied

- usecase.1 = extract code from error ✓
- usecase.2 = default codes on built-in errors ✓
- usecase.3 = supply code at throw time ✓
- usecase.4 = define error class with baked-in code ✓
- usecase.5 = inherit code through class hierarchy ✓
- usecase.6 = merge instance code with class code ✓
- usecase.7 = partial codes are valid ✓
- usecase.8 = serialization omits code without slug ✓
- usecase.9 = backwards compatibility ✓

---

## subcomponent contracts

### code type

given('HelpfulErrorCode type contract')
  then('shape is { http?: number; slug?: string }')
  then('both fields are optional')
  then('exported for consumer use')

### HelpfulError.code getter

given('HelpfulError.prototype.code getter contract')
  then('returns HelpfulErrorCode | undefined')
  then('merges class static code with instance metadata code')
  then('instance code fields override class code fields')
  then('returns undefined when no code exists anywhere in chain')

### HelpfulError.code static

given('HelpfulError static code contract')
  then('HelpfulError.code is undefined')
  then('subclasses may declare static code: HelpfulErrorCode')
  then('static code is inherited via standard js prototype chain')

### BadRequestError.code static

given('BadRequestError static code contract')
  then('BadRequestError.code is { http: 400 }')
  then('slug is undefined by default')

### UnexpectedCodePathError.code static

given('UnexpectedCodePathError static code contract')
  then('UnexpectedCodePathError.code is { http: 500 }')
  then('slug is undefined by default')

### constructor metadata.code

given('HelpfulError constructor contract for code')
  then('accepts optional code field in metadata')
  then('code: HelpfulErrorCode stores for merge with class code')
  then('code: null clears any class code')
  then('other metadata fields are unaffected')

### toJSON serialization

given('HelpfulError.prototype.toJSON contract for code')
  then('includes code in output only when slug is present')
  then('omits code when slug is absent')
  then('when included, code contains both http and slug')

---

## composition boundaries

given('code getter composition')
  then('reads static code from constructor prototype chain')
  then('reads instance code from metadata')
  then('merges with instance fields over class fields')
  then('returns undefined if both sources are empty')

given('code serialization composition')
  then('toJSON checks merged code for slug presence')
  then('if slug present, includes full code object')
  then('if slug absent, omits code field entirely')

given('metadata isolation')
  then('code field in metadata does not pollute error.metadata')
  then('error.metadata returns metadata without code extracted')
    sothat('code does not appear twice in serialization')

---

## test coverage criteria

given('unit tests')
  then('tests HelpfulError.code returns undefined by default')
  then('tests BadRequestError.code.http is 400')
  then('tests UnexpectedCodePathError.code.http is 500')
  then('tests instance code override via metadata')
  then('tests code: null clears class code')
  then('tests partial code merge (slug only, http only)')
  then('tests toJSON omits code when no slug')
  then('tests toJSON includes code when slug present')

given('inheritance tests')
  then('tests custom subclass inherits parent code')
  then('tests custom subclass can override parent code')
  then('tests multi-level inheritance chain')

given('integration tests')
  then('tests full throw-catch-serialize cycle')
  then('tests error.code accessible in catch block')
  then('tests JSON.stringify produces expected output')

given('backwards compatibility tests')
  then('tests prior error instantiation patterns still work')
  then('tests error.message unchanged')
  then('tests error.metadata unchanged for non-code metadata')
